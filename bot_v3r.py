# -*- coding: utf-8 -*-
"""bot_v3r.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17lKgG01pPHc25Ka_KqHlaJ6VxtwQdogC
"""

# ================== IMPORTS ==================
import os
import asyncio
import sqlite3
import nest_asyncio
import tempfile
import aiohttp
import language_tool_python
import whisper
import logging
from aiogram import Bot, Dispatcher, F
from aiogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton

logging.basicConfig(level=logging.INFO)

# ================== CONFIG ==================
BOT_TOKEN = os.getenv("BOT_TOKEN")
if not BOT_TOKEN:
    raise ValueError("‚ùå BOT_TOKEN not found. Please set it in Render Environment Variables.")

bot = Bot(token=BOT_TOKEN)
dp = Dispatcher()
tool = language_tool_python.LanguageTool('en-US')
whisper_model = whisper.load_model("small")

# Keep track of question ‚Üí answer flow
user_context = {}

# ================== DATABASE ==================
def init_db():
    conn = sqlite3.connect("users.db")
    c = conn.cursor()
    c.execute("""CREATE TABLE IF NOT EXISTS users (
                    user_id INTEGER PRIMARY KEY,
                    username TEXT
                )""")
    conn.commit()
    conn.close()

def add_or_get_user(user_id: int, username: str):
    conn = sqlite3.connect("users.db")
    c = conn.cursor()
    c.execute("SELECT * FROM users WHERE user_id = ?", (user_id,))
    user = c.fetchone()
    if not user:
        c.execute("INSERT INTO users (user_id, username) VALUES (?, ?)", (user_id, username))
        conn.commit()
        result = "new"
    else:
        result = "existing"
    conn.close()
    return result

# ================== KEYBOARDS ==================
def main_menu():
    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="‚úçÔ∏è Writing", callback_data="writing")],
        [InlineKeyboardButton(text="üéô Speaking", callback_data="speaking")],
        [InlineKeyboardButton(text="‚ùì Help", callback_data="help")],
        [InlineKeyboardButton(text="üì© Contact Us", callback_data="contact")],
        [InlineKeyboardButton(text="AI/ChatGPT Mode(soon)", callback_data="ChatGpt")],
        [InlineKeyboardButton(text="Subscription(soon)", callback_data="subs")],
    ])
    return kb

# ================== START HANDLER ==================
@dp.message(F.text == "/start")
async def start(message: Message):
    status = add_or_get_user(message.from_user.id, message.from_user.username or "unknown")
    if status == "new":
        await message.answer(f"üëã Welcome, {message.from_user.first_name}! You are now registered.", reply_markup=main_menu())
    else:
        await message.answer(f"üëã Welcome back, {message.from_user.first_name}!", reply_markup=main_menu())

# ================== WRITING FLOW ==================
@dp.callback_query(F.data == "writing")
async def writing_intro(callback):
    user_context[callback.from_user.id] = {"mode": "writing", "question": None}
    await callback.message.answer("‚úçÔ∏è Please send me the IELTS Writing Task 2 question first.")

@dp.message(F.text & ~F.text.startswith("/"))
async def handle_writing(message: Message):
    uid = message.from_user.id
    if uid in user_context and user_context[uid]["mode"] == "writing":
        if not user_context[uid]["question"]:
            # Save question
            user_context[uid]["question"] = message.text
            await message.answer("‚úÖ Question saved. Now send me your essay (200‚Äì300 words).")
        else:
            # Essay
            question = user_context[uid]["question"]
            essay = message.text
            processing_msg = await message.answer("‚è≥ Evaluating your essay...")

            try:
                feedback = evaluate_writing(essay, question)

                await bot.delete_message(message.chat.id, processing_msg.message_id)
                await message.answer(
                    f"üìä *IELTS Writing Evaluation*:\n{feedback}",
                    parse_mode="Markdown",
                    reply_markup=main_menu()
                )
            except Exception as e:
                await bot.delete_message(message.chat.id, processing_msg.message_id)
                await message.answer(f"‚ö†Ô∏è Error: {str(e)}", reply_markup=main_menu())
            del user_context[uid]

def evaluate_writing(essay: str, question: str) -> str:
    words = essay.split()
    word_count = len(words)

    # Grammar check
    matches = tool.check(essay)
    grammar_errors = len(matches)

    # Vocabulary richness
    vocab_ratio = len(set(words)) / max(1, len(words))

    # Linking words
    connectors = ["however", "moreover", "in conclusion", "although", "on the other hand"]
    connector_count = sum(essay.lower().count(c) for c in connectors)

    # Relevance to question
    q_keywords = [w.lower() for w in question.split() if len(w) > 4]
    overlap = len(set(q_keywords) & set(essay.lower().split())) / max(1, len(set(q_keywords)))

    # ---- Scoring ----
    task_score = 3.5 + (0.5 if word_count >= 250 else 0) + (0.5 if overlap > 0.3 else 0)
    cohesion_score = 3.5 + (0.5 if connector_count >= 2 else 0)
    lexical_score = 3.5 + (0.5 if vocab_ratio > 0.35 else 0)
    grammar_score = 3.5 + (0.5 if grammar_errors < 10 else 0)

    overall = (task_score + cohesion_score + lexical_score + grammar_score) / 4

    return (
        f"**Task Achievement: {task_score:.1f}**\n"
        f"**Coherence & Cohesion: {cohesion_score:.1f}**\n"
        f"**Lexical Resource: {lexical_score:.1f}**\n"
        f"**Grammatical Range & Accuracy: {grammar_score:.1f}**\n\n"
        f"üíØ **Overall Band: {overall:.1f}**"
    )


# ================== SPEAKING FLOW ==================
@dp.callback_query(F.data == "speaking")
async def speaking_intro(callback):
    user_context[callback.from_user.id] = {"mode": "speaking", "question": None}
    await callback.message.answer("üé§ Please type the IELTS Speaking question first.")

@dp.message(F.voice)
async def handle_voice(message: Message):
    uid = message.from_user.id
    if uid not in user_context or user_context[uid]["mode"] != "speaking" or not user_context[uid]["question"]:
        await message.answer("‚ö†Ô∏è Please first provide a question before sending voice.")
        return

    processing_msg = await message.answer("‚è≥ Transcribing your voice...")

    try:
        file = await bot.get_file(message.voice.file_id)
        file_path = file.file_path
        file_url = f"https://api.telegram.org/file/bot{BOT_TOKEN}/{file_path}"

        temp_file = tempfile.NamedTemporaryFile(delete=False, suffix=".ogg")
        async with aiohttp.ClientSession() as session:
            async with session.get(file_url) as resp:
                temp_file.write(await resp.read())
        temp_file.close()

        result = whisper_model.transcribe(temp_file.name)
        transcript = result["text"]
        os.remove(temp_file.name)

        question = user_context[uid]["question"]
        feedback = evaluate_speaking(transcript, question)

        await bot.delete_message(message.chat.id, processing_msg.message_id)
        await message.answer(
            f"üìù *Transcription*:\n{transcript}\n\nüìä *IELTS Speaking Evaluation*:\n{feedback}",
            parse_mode="Markdown",
            reply_markup=main_menu()
        )
    except Exception as e:
        await bot.delete_message(message.chat.id, processing_msg.message_id)
        await message.answer(f"‚ö†Ô∏è Error: {str(e)}", reply_markup=main_menu())
    del user_context[uid]

def evaluate_speaking(transcript: str, question: str) -> str:
    words = transcript.split()
    word_count = len(words)

    # Fluency (based on length)
    fluency_score = 3.5
    if word_count >= 80:
        fluency_score += 1.0
    elif word_count >= 40:
        fluency_score += 0.5

    # Vocabulary (variety of words)
    vocab_ratio = len(set(words)) / max(1, len(words))
    lexical_score = 3.5 + (1.0 if vocab_ratio > 0.35 else 0.5 if vocab_ratio > 0.25 else 0)

    # Grammar (markers)
    grammar_score = 3.5 + (0.5 if any(w in transcript.lower() for w in ["however", "because", "although"]) else 0)

    # Task relevance (compatibility with question)
    q_keywords = [w.lower() for w in question.split() if len(w) > 4]
    overlap = len(set(q_keywords) & set(transcript.lower().split())) / max(1, len(set(q_keywords)))
    task_score = 3.5 + (1.0 if overlap > 0.5 else 0.5 if overlap > 0.2 else 0)

    overall = (fluency_score + lexical_score + grammar_score + task_score) / 4

    return (
        f"**Task Achievement: {task_score:.1f}**\n"
        f"**Fluency: {fluency_score:.1f}**\n"
        f"**Lexical Resource: {lexical_score:.1f}**\n"
        f"**Grammatical Range & Accuracy: {grammar_score:.1f}**\n\n"
        f"üíØ **Overall Band: {overall:.1f}**"
    )

# ================== HELP & CONTACT ==================
@dp.callback_query(F.data == "help")
async def help_section(callback):
    help_text = (
        "‚ùì *Help Section*\n\n"
        "This bot helps you practice for the IELTS exam:\n"
        "- ‚úçÔ∏è Writing: Submit IELTS Task 2 questions and essays for evaluation.\n"
        "- üéô Speaking: Provide a question and record your speaking answer.\n\n"
        "üìä You‚Äôll get feedback and estimated band scores."
    )
    await callback.message.answer(help_text, parse_mode="Markdown", reply_markup=main_menu())


@dp.callback_query(F.data == "contact")
async def contact_section(callback):
    print("üì© Contact button clicked!")  # Debugging log
    contact_text = (
        "üì© *Contact Us*\n\n"
        "If you have questions, feedback, or need support:\n"
        "- Telegram: @mukhsinov_9701\n"
        "- Email: aspectrest@gmail.com\n"
    )
    await callback.message.answer(contact_text, parse_mode="Markdown", reply_markup=main_menu())

@dp.callback_query(F.data == "subs")
async def subs_section(callback):
    subs_section_text = ("Soon will be available...")
    await callback.message.answer(subs_section_text, parse_mode="Markdown", reply_markup=main_menu())
@dp.callback_query(F.data == "ChatGpt")
async def ChatGpt_section(callback):
    ChatGpt_section_text = ("Soon will be available...  ")
    await callback.message.answer(ChatGpt_section_text, parse_mode="Markdown", reply_markup=main_menu())

# ================== MAIN ==================
async def main():
    init_db()
    logging.info("ü§ñ Bot is running...")
    await dp.start_polling(bot)

nest_asyncio.apply()
try:
    loop = asyncio.get_event_loop()
    if loop.is_running():
        loop.create_task(main())
    else:
        loop.run_until_complete(main())
except Exception as e:
    logging.error(f"Bot crashed: {e}")